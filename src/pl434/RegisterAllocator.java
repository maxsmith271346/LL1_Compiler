package pl434;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import SSA.*;
import SSA.BasicBlock.Transitions;
import SSA.IntermediateInstruction.SSAOperator;
import types.VoidType;

public class RegisterAllocator {
    public SSA ssa;
    public int numRegs;
    //HashMap<Operand, Set<Operand>> interferenceGraph;
    HashMap<String, Set<String>> interferenceGraph; // each var will be its name (without subscripts with its scope appended) - this became an issue for global vars in functions
    HashMap<String, Set<String>> tempInterferenceGraph;
    //HashMap<Operand, Integer> colorMap;
    HashMap<String, Integer> colorMap;
    List<Integer> allColors;
    //int spillOffset;

    public RegisterAllocator(SSA ssa, int numRegs){
        this.ssa = ssa;
        this.numRegs = numRegs;
        //interferenceGraph = new HashMap<Operand, Set<Operand>>();
        interferenceGraph = new HashMap<String, Set<String>>();

        //colorMap = new HashMap<Operand, Integer>();
        colorMap = new HashMap<String, Integer>();
        allColors = new ArrayList<Integer>();
        //spillOffset = -4;

        allColors = IntStream.rangeClosed(1, numRegs - 2).boxed().collect(Collectors.toList());
        eliminatePhis();

        // need to clear out the previous liveness analysis because the graph has been changed after elimniating the phis
        /*for (BasicBlock bb : ssa.getBasicBlockList()){
            bb.lvEntry.clear();
            bb.lvExit.clear();
            for (IntermediateInstruction ii : bb.getIntInsList()){
                ii.getLiveVars().clear();
            }
        }*/

        buildInterferenceGraph();
        //System.out.println("ssa " + ssa.asDotGraph());
        colorInterferenceGraph();
        
        /*for (String o : colorMap.keySet()){
            System.out.println("o " + o + " color " + colorMap.get(o));
        }*/
        
        insertRegisters();
        removeSillyMoves();
    }

    public void buildInterferenceGraph(){
        generateLivenessAnalysis();
        // based on the liveness analysis, build an interference graph 
        //System.out.println("liveness analysis: " + ssa.asDotGraph());

       //System.out.println("after liveness analysis " + ssa.asDotGraph());
        for (BasicBlock bb : ssa.getBasicBlockList()){
            if (bb.name().contains("elim")){continue;}
            addToInterferenceGraph(bb.lvEntry);
            addToInterferenceGraph(bb.lvExit);
            for (IntermediateInstruction ii : bb.getIntInsList()){
                if (ii.isElim()){continue;}
                addToInterferenceGraph(ii.liveVars);
            }
        }
    
        /*for (String o : interferenceGraph.keySet()){
            System.out.println("key: " + o + " value " + interferenceGraph.get(o));
        }*/
        
    }

    public void addToInterferenceGraph(HashSet<Operand> liveVars){
        for (Operand o : liveVars){
            if (o instanceof GDB){continue;}
            if (IntermediateInstruction.isConst(o)){continue;}
            Set<String> adjSet;
            if (interferenceGraph.containsKey(getOpString(o))){
                adjSet = interferenceGraph.get(getOpString(o));
            }
            else{ 
                adjSet = new HashSet<String>();
            }
            for (Operand oAdj : liveVars){
                if (IntermediateInstruction.isConst(oAdj)){continue;}
                if (!o.equals(oAdj) && !(oAdj instanceof GDB)){
                    adjSet.add(getOpString(oAdj));
                }
            }
            interferenceGraph.put(getOpString(o), adjSet);
        }
    }

    public String getOpString(Operand op){
        String opString = op.toString();
        if (opString.contains("_")){
            opString = opString.substring(0, opString.lastIndexOf("_")); 
        }
        if (op instanceof Symbol){
            opString += ((Symbol) op).scope;
        }
        return opString;
    }

    public void generateLivenessAnalysis(){
        // track the live randes of all the individual values generated by the program being compiled
        HashMap<BasicBlock, Integer> exitSetCount = new HashMap<BasicBlock, Integer>();
        Set<BasicBlock> bbList = ssa.getBasicBlockList();

        for (BasicBlock bb : ssa.getBasicBlockList()) {
            if (bb.name().contains("elim")){continue;}
            exitSetCount.put(bb, 0);
            for (Transitions t : bb.transitionList) {
                t.toBB.addInEdge(bb);
            }
        }

        // Ensure proper visiting order for global liveness analysis
        Boolean change = false;
        do {
            // System.out.println("print");
            change = false;
            for (BasicBlock block: bbList) {
                if (block.name().contains("elim")){continue;}
                change |= block.liveAnalysis();
            }
        } while (change);
    }

    public void colorInterferenceGraph(){
        // Then, color the resulting graph, assign registers to the variables (& the instruction numbers? )
        // If spilling occurs, then map the values that cannot be accomodated onto virtual registers in memory

        List<Integer> availColors = new ArrayList<Integer>(allColors);

        // base case 
        if (interferenceGraph.size() == 0){
            return;
        }

        // Find a node with fewer than k outgoing edges 
        String node = null;
        for (String o : interferenceGraph.keySet()){
            if (interferenceGraph.get(o).size() < numRegs){
                node = o;
            }
        }
        HashMap<String, Set<String>> beforeGraph = new HashMap<String, Set<String>>();
        for (String s : interferenceGraph.keySet()){
            Set<String> newSet = new HashSet<String>();
            for (String sAdj : interferenceGraph.get(s)){
                newSet.add(sAdj);
            }
            beforeGraph.put(s, newSet);
        }

        // remove it from the graph
        if (node != null){
            removeNode(interferenceGraph, node);
        }
        else{ 
            // if we cannot find a node with fewer than k neighbors
            // choose and remove an arbitrary node & mark it as "troublesome"
            node = interferenceGraph.keySet().iterator().next(); // should base this selection on heuristic (maybe with most neighbors?)
            removeNode(interferenceGraph, node);
        }

        // recursively color the rest of the graph
        colorInterferenceGraph();

        interferenceGraph = beforeGraph;

        // Assign the node a valid color
        // remove all the colors that have already been assigned to the neighboring nodes
        for (String o : interferenceGraph.get(node)){
            if (colorMap.containsKey(o)){
                availColors.remove(colorMap.get(o));
            }
        }   

        if (availColors.size() != 0){ 
            colorMap.put(node, availColors.get(0));
        }
        else{ 
            colorMap.put(node, -1);
        }
    }

    public void removeNode(HashMap<String, Set<String>> graph, String node){
        Set<String> toRemove = new HashSet<String>();

        graph.remove(node);
        for (String o : graph.keySet()){
            for (String oAdj : graph.get(o)){
                if (oAdj.equals(node)){
                    toRemove.add(oAdj);
                }
            }
            graph.get(o).removeAll(toRemove);
        }
    }

    public void eliminatePhis(){
        // need this for inList
        generateLivenessAnalysis();

        // Eliminate all phi instructions, inserting move instructions wherever necessary
        for (BasicBlock bb : ssa.getBasicBlockList()){
            if (bb.name().contains("elim")){continue;}
            List<IntermediateInstruction> toRemove = new ArrayList<IntermediateInstruction>();

            for (IntermediateInstruction ii : bb.getIntInsList()){
                if (ii.isElim()){continue;}
                if (ii.getOperator() == SSAOperator.PHI){
                    if (ii.getOperandOne() instanceof Symbol){
                        Symbol opOne = (Symbol) ii.getOperandOne();
                        int opOneInsNum = Integer.parseInt(opOne.name().substring(opOne.name().lastIndexOf("_") + 1, opOne.name().length()));
                        Symbol opTwo = (Symbol) ii.getOperandTwo();
                        int opTwoInsNum = Integer.parseInt(opTwo.name().substring(opTwo.name().lastIndexOf("_") + 1, opTwo.name().length()));

                        IntermediateInstruction moveInsOne = new IntermediateInstruction(SSAOperator.MOVE, opOne, ii.phiSymbol, BasicBlock.insNumber, new VoidType());
                        IntermediateInstruction moveInsTwo = new IntermediateInstruction(SSAOperator.MOVE, ii.getOperandTwo(), ii.phiSymbol, BasicBlock.insNumber, new VoidType());

                        if (bb.inList.get(0).hasInsNum(opOneInsNum) || bb.inList.get(1).hasInsNum(opTwoInsNum) ){
                            bb.inList.get(0).addEnd(moveInsOne, false);
                            bb.inList.get(1).addEnd(moveInsTwo, false);
                        }
                        else { 
                            bb.inList.get(1).addEnd(moveInsOne, false);
                            bb.inList.get(0).addEnd(moveInsTwo, false);
                        }
                        ii.eliminate();
                    }
                }
            }

            //bb.getIntInsList().removeAll(toRemove);
        }

        //System.out.println("After Eliminating PHIs " + ssa.asDotGraph());
    }

    public void insertRegisters(){
        // replace operands with their registers 
        for (BasicBlock bb : ssa.getBasicBlockList()){
            if (bb.name().contains("elim")){continue;}
            for (IntermediateInstruction ii : bb.getIntInsList()){
                if (ii.isElim()){continue;}
                
               // System.out.println("ii " + ii);
                if(ii.getOperandOne() != null){
                    if (ii.getOperandOne() instanceof GDB){
                        ii.putRegisterOne(30);
                    }
                    else if (colorMap.containsKey(getOpString(ii.getOperandOne()))){
                        if (colorMap.get(getOpString(ii.getOperandOne())) > 0){
                            ii.putRegisterOne(colorMap.get(getOpString(ii.getOperandOne())));
                            //System.out.println("put register into " + ii + " R1: " + ii.getRegisterOne());
                        }
                    }
                    else{
                        for (String o : colorMap.keySet()){
                            if (o.equals(getOpString(ii.getOperandOne()))){
                                if (colorMap.get(o) > 0){
                                    ii.putRegisterOne(colorMap.get(o));
                                }
                            }
                        }
                    }
                }
                

                if (ii.getOperandTwo() != null){
                    if (ii.getOperandTwo() instanceof GDB){
                        ii.putRegisterTwo(30);
                    }
                    else if (colorMap.containsKey(getOpString(ii.getOperandTwo()))){
                        if (colorMap.get(getOpString(ii.getOperandTwo())) > 0){
                            ii.putRegisterTwo(colorMap.get(getOpString(ii.getOperandTwo())));
                        }
                    }
                    else{
                        for (String o : colorMap.keySet()){
                            if (o.equals(getOpString(ii.getOperandTwo()))){
                                if (colorMap.get(o) > 0){
                                    ii.putRegisterTwo(colorMap.get(o));
                                }
                            }
                        }
                    }
                }
                

                if (ii.getExtraOperands() != null) {
                    // assign registers to extra operands
                    List<Integer> extraRegisters = new ArrayList<Integer>();
                    List<Operand> extraOperands = ii.getExtraOperands();
                    for (int i = 0; i < extraOperands.size()-1; i++) {

                        if (extraOperands.get(i) != null) {
                            if (colorMap.containsKey(getOpString(extraOperands.get(i)))) {
                                if (colorMap.get(getOpString(extraOperands.get(i))) > 0) {
                                    extraRegisters.add(colorMap.get(getOpString(extraOperands.get(i))));
                                }
                            }
                            else{
                                for (String o : colorMap.keySet()){
                                    if (o.equals(getOpString(extraOperands.get(i)))){
                                        if (colorMap.get(o) > 0){
                                            ii.putRegisterTwo(colorMap.get(o));
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ii.putExtraRegisters(extraRegisters);
                }
                
                if (colorMap.containsKey(getOpString(ii.instNum()))){
                    //System.out.println("here");
                    //ii.putOperandTwo(colorMap.get(ii.instNum()));
                    ii.returnReg = colorMap.get(getOpString(ii.instNum()));
                    /*if (colorMap.get(getOpString(ii.instNum())) < 0){ 
                        // need to add a store instruction here
                    }*/
                }
            }
        }

        //System.out.println("after inserting registers " + ssa.asDotGraph());
    }

    public void removeSillyMoves(){
        // Remove all silly move instructions after register assignment (e.g., R5 = R5)
        for (BasicBlock bb : ssa.getBasicBlockList()){
            if (bb.name().contains("elim")){continue;}
            for (IntermediateInstruction ii : bb.getIntInsList()){
                if (ii.isElim()){continue;}
                if (ii.getOperator() == SSAOperator.MOVE){
                    if (ii.getRegisterOne() != null && ii.getRegisterTwo() != null){
                        if (ii.getRegisterOne().equals(ii.getRegisterTwo())){
                            ii.eliminate();
                            ii.eliminateSilly();
                        }
                    }
                    else if(ii.getRegisterOne() == null && ii.getRegisterTwo() == null){
                        if (getOpString(ii.getOperandOne()).equals(getOpString(ii.getOperandTwo()))){
                            //System.out.println("ii " + ii);
                            ii.eliminate();
                        }
                    }
                }
            }
        }
        //System.out.println("after removing silly moves " + ssa.asDotGraph());
    }
}
